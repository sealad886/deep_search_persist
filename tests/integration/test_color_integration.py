"""
Integration tests for the CAM16-UCS color space implementation and its integration with color scheme generation.
"""

import unittest
import sys
from pathlib import Path
import os
import tempfile
import subprocess

from ...deep_search_persist.simple_webui.utils.color_schemes import generate_perceptual_palette
from ...deep_search_persist.simple_webui.utils.hue_spacing_calculator import validate_palette_accessibility
from ...deep_search_persist.simple_webui.utils.color_convert import hex_to_rgb  # Used for basic validation


class TestColorIntegration(unittest.TestCase):
    """Integration test class for color-related modules."""

    def test_generate_perceptual_palette_integration(self):
        """
        Test the integration of generate_perceptual_palette with CAM16-UCS and hue spacing.
        Verify that palettes generated by color_schemes.py meet perceptual distance criteria.
        """
        base_color = "#1E90FF"  # Dodger Blue
        count = 8
        min_perceptual_distance = 25.0

        # 1. Generate palette using the function from color_schemes.py
        palette = generate_perceptual_palette(base_color, count, min_perceptual_distance)

        # 2. Assert basic properties of the generated palette
        self.assertIsInstance(palette, list)
        self.assertEqual(len(palette), count)
        for color in palette:
            self.assertIsInstance(color, str)
            self.assertTrue(color.startswith('#'))
            self.assertEqual(len(color), 7)
            # Verify it's a valid hex color
            try:
                hex_to_rgb(color)
            except (ValueError, TypeError):
                self.fail(f"Generated invalid hex color: {color}")

        # 3. Validate the generated palette using the function from hue_spacing_calculator.py
        # This verifies that the integration results in a perceptually spaced palette.
        validation_result = validate_palette_accessibility(palette, min_perceptual_distance)

        self.assertTrue(
            validation_result["valid"],
            "Generated palette failed perceptual distance validation: "
            f"{validation_result.get('violations', 'No violations reported')}"
        )
        # Allow a small tolerance for floating point calculations
        self.assertGreaterEqual(
            validation_result.get("min_distance", 0), min_perceptual_distance - 1.0,
            "Minimum perceptual distance not met in generated palette (allowing small tolerance)"
        )

    def test_generate_perceptual_palette_edge_cases(self):
        """Test generate_perceptual_palette with edge case counts (0 and 1)."""
        base_color = "#FF0000"  # Red

        # Test count = 0
        palette_0 = generate_perceptual_palette(base_color, 0)
        self.assertEqual(len(palette_0), 0)
        self.assertIsInstance(palette_0, list)

        # Test count = 1
        palette_1 = generate_perceptual_palette(base_color, 1)
        self.assertEqual(len(palette_1), 1)
        self.assertEqual(palette_1[0].upper(), base_color.upper())
        self.assertIsInstance(palette_1, list)
        self.assertIsInstance(palette_1[0], str)

    def test_generate_perceptual_palette_different_inputs(self):
        """Test generate_perceptual_palette with different base colors and min_step."""
        test_cases = [
            ("#00FF00", 5, 30.0),  # Green, 5 colors, step 30
            ("#0000FF", 10, 20.0), # Blue, 10 colors, step 20
            ("#808080", 6, 25.0),  # Grayscale, 6 colors, step 25
            ("#FFFF00", 7, 35.0),  # Yellow, 7 colors, step 35
        ]

        for base_color, count, min_step in test_cases:
            with self.subTest(base_color=base_color, count=count, min_step=min_step):
                palette = generate_perceptual_palette(base_color, count, min_step)

                self.assertIsInstance(palette, list)
                self.assertEqual(len(palette), count)
                for color in palette:
                    self.assertIsInstance(color, str)
                    self.assertTrue(color.startswith('#'))
                    self.assertEqual(len(color), 7)
                    try:
                        hex_to_rgb(color)
                    except (ValueError, TypeError):
                        self.fail(f"Generated invalid hex color: {color}")

                # Validate perceptual distance
                validation_result = validate_palette_accessibility(palette, min_step)
                self.assertTrue(
                    validation_result["valid"],
                    f"Generated palette failed perceptual distance validation for {base_color}, count={count}, min_step={min_step}: "
                    f"{validation_result.get('violations', 'No violations reported')}"
                )
                self.assertGreaterEqual(
                    validation_result.get("min_distance", 0), min_step - 1.0,
                    "Minimum perceptual distance not met (allowing small tolerance)"
                )


    def test_pre_commit_hook_valid_file(self):
        """Test the pre-commit hook with a valid color scheme file."""
        valid_content = """
colors:
  - "#1E90FF"
  - "#32CD32"
  - "#FFD700"
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.color-scheme.yaml', delete=False) as tmp_file:
            tmp_file.write(valid_content)
            tmp_file_path = tmp_file.name

        try:
            # Construct the command to run the pre-commit hook
            hook_path = Path(__file__).parent.parent.parent / ".pre-commit-hooks" / "color-validation.py"
            command = [sys.executable, str(hook_path), tmp_file_path]

            # Execute the command
            result = subprocess.run(command, capture_output=True, text=True)

            # Assert the exit code (0 for success)
            self.assertEqual(result.returncode, 0, f"Pre-commit hook failed for valid file. Output:\n{result.stdout}\nError:\n{result.stderr}")

            # Assert expected output
            self.assertIn("✅ All color validations passed!", result.stdout)

        finally:
            # Clean up the temporary file
            os.remove(tmp_file_path)


    def test_pre_commit_hook_invalid_file(self):
        """Test the pre-commit hook with an invalid color scheme file (accessibility violations)."""
        invalid_content = """
colors:
  - "#CCCCCC"
  - "#DDDDDD"
""" # Low contrast colors
        with tempfile.NamedTemporaryFile(mode='w', suffix='.color-scheme.yaml', delete=False) as tmp_file:
            tmp_file.write(invalid_content)
            tmp_file_path = tmp_file.name

        try:
            hook_path = Path(__file__).parent.parent.parent / ".pre-commit-hooks" / "color-validation.py"
            command = [sys.executable, str(hook_path), tmp_file_path]

            result = subprocess.run(command, capture_output=True, text=True)

            # Assert the exit code (non-zero for failure)
            self.assertNotEqual(result.returncode, 0, f"Pre-commit hook passed for invalid file. Output:\n{result.stdout}\nError:\n{result.stderr}")

            # Assert expected output indicating failure
            self.assertIn("❌ Color validation failed!", result.stdout)
            self.assertIn("violations", result.stdout)

        finally:
            os.remove(tmp_file_path)


    def test_pre_commit_hook_malformed_file(self):
        """Test the pre-commit hook with a malformed file (invalid YAML)."""
        malformed_content = """
colors:
- "#ABCDEF"
  - "#123456" # Incorrect indentation
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.color-scheme.yaml', delete=False) as tmp_file:
            tmp_file.write(malformed_content)
            tmp_file_path = tmp_file.name

        try:
            hook_path = Path(__file__).parent.parent.parent / ".pre-commit-hooks" / "color-validation.py"
            command = [sys.executable, str(hook_path), tmp_file_path]

            result = subprocess.run(command, capture_output=True, text=True)

            # Assert the exit code (non-zero for failure)
            self.assertNotEqual(result.returncode, 0, f"Pre-commit hook passed for malformed file. Output:\n{result.stdout}\nError:\n{result.stderr}")

            # Assert expected output indicating error
            self.assertIn("Error loading", result.stdout)
            self.assertIn("❌", result.stdout)

        finally:
            os.remove(tmp_file_path)


    def test_pre_commit_hook_no_colors_file(self):
        """Test the pre-commit hook with a file containing no hex colors."""
        no_colors_content = """
This file has no colors.
It just has some text.
"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as tmp_file:
            tmp_file.write(no_colors_content)
            tmp_file_path = tmp_file.name

        try:
            hook_path = Path(__file__).parent.parent.parent / ".pre-commit-hooks" / "color-validation.py"
            command = [sys.executable, str(hook_path), tmp_file_path]

            result = subprocess.run(command, capture_output=True, text=True)

            # Assert the exit code (0 for success)
            self.assertEqual(result.returncode, 0, f"Pre-commit hook failed for no colors file. Output:\n{result.stdout}\nError:\n{result.stderr}")

            # Assert expected output
            self.assertIn("No colors found", result.stdout)

        finally:
            os.remove(tmp_file_path)


if __name__ == '__main__':
    unittest.main(verbosity=2)
